# Search Engine Core - Cursor AI Rules

## Project Context
This is a high-performance search engine built with C++, uWebSockets, MongoDB, and Redis. The project uses Docker for containerization and includes features like web crawling, SPA rendering, and sponsor management.

## Critical MongoDB C++ Rules

### ⚠️ MOST IMPORTANT: MongoDB Instance Initialization
**NEVER create MongoDB clients without proper instance initialization:**
```cpp
// ❌ WRONG - This will crash the server!
mongocxx::uri uri{"mongodb://localhost:27017"};
client_ = std::make_unique<mongocxx::client>(uri); // CRASH!
```

**ALWAYS use the singleton pattern:**
```cpp
// ✅ CORRECT
#include "../../include/mongodb.h"
mongocxx::instance& instance = MongoDBInstance::getInstance();
mongocxx::uri uri{"mongodb://localhost:27017"};
client_ = std::make_unique<mongocxx::client>(uri); // Works!
```

### MongoDB Integration Checklist
When implementing MongoDB functionality:
1. Include `#include "../../include/mongodb.h"`
2. Call `MongoDBInstance::getInstance()` before creating any client
3. Use consistent collection names across imports and code
4. Add proper exception handling with try-catch blocks
5. Test connection with simple query first

## Build and Deployment Rules

### Local Build Process
```bash
cd /root/search-engine-core
mkdir -p build && cd build
cmake .. && make -j4
```

### Docker Deployment
```bash
# Build locally and copy to container
docker cp /root/search-engine-core/build/server core:/app/server
docker restart core

# Or use Docker Compose
cd /root/search-engine-core
docker compose up --build
```

## Code Style and Patterns

### Controller Registration
All new API endpoints must be registered in the controller:
```cpp
// In HomeController.h
void myNewEndpoint(uWS::HttpResponse<false>* res, uWS::HttpRequest* req);

// Register the route
REGISTER_ROUTE(HttpMethod::POST, "/api/v2/my-endpoint", myNewEndpoint, HomeController);
```

### Error Handling Pattern
```cpp
try {
    // MongoDB operations
    mongocxx::instance& instance = MongoDBInstance::getInstance();
    // ... rest of code
} catch (const mongocxx::exception& e) {
    LOG_ERROR("MongoDB error: " + std::string(e.what()));
    serverError(res, "Database error occurred");
}
```

### Logging Standards
- Use `LOG_INFO()` for normal operations
- Use `LOG_ERROR()` for errors
- Use `LOG_DEBUG()` for debugging (only in debug builds)
- Use `LOG_WARNING()` for warnings

## ⚠️ CRITICAL: Configurable Debug Output Rules

### MANDATORY: Environment-Based Debug Configuration
**NEVER use hardcoded debug output - ALWAYS make it configurable via LOG_LEVEL:**

```cpp
// ❌ WRONG - Hardcoded debug output (breaks production performance)
std::cout << "[DEBUG] Processing request: " << requestId << std::endl;

// ✅ CORRECT - Configurable debug logging
LOG_DEBUG("Processing request: " + std::to_string(requestId));

// ✅ EVEN BETTER - Structured debug logging
LOG_DEBUG("Processing request with ID: " + std::to_string(requestId) +
          ", method: " + std::string(method) +
          ", timestamp: " + getCurrentTimestamp());
```

### Debug Output Configuration Rules

1. **ALWAYS use `LOG_DEBUG()` instead of `std::cout`** for debug messages
2. **NEVER use `std::cout`** for application debug output
3. **ALWAYS configure log level via `LOG_LEVEL` environment variable**
4. **NEVER hardcode debug verbosity** - let environment control it
5. **ALWAYS test with different log levels** before committing

### LOG_LEVEL Environment Variable Usage

```bash
# Development - Full debug output
LOG_LEVEL=debug docker-compose up

# Production - Standard logging only
LOG_LEVEL=info docker-compose up

# High-performance - Minimal logging
LOG_LEVEL=warning docker-compose up

# Silent operation - Errors only
LOG_LEVEL=error docker-compose up

# No logging - Maximum performance
LOG_LEVEL=none docker-compose up
```

### Available Log Levels

| Level | Use Case | What Gets Logged |
|-------|----------|------------------|
| `trace` | Deep debugging | Everything including execution flow |
| `debug` | Development | WebSocket, crawler, API calls, performance |
| `info` | Production | Standard operations, system status |
| `warning` | High-performance | Non-critical issues, performance warnings |
| `error` | Critical monitoring | System failures, database errors |
| `none` | Performance testing | No logging output |

### Debug Output Migration Checklist

When adding new debug output:
1. [ ] **Use `LOG_DEBUG()` instead of `std::cout`**
2. [ ] **Test with `LOG_LEVEL=debug`** to ensure output appears
3. [ ] **Test with `LOG_LEVEL=info`** to ensure output is suppressed
4. [ ] **Document the debug message purpose** in comments
5. [ ] **Use structured logging** with clear, searchable messages

### Why Configurable Debug Output Matters

1. **Performance**: Debug output can significantly slow down production systems
2. **Security**: Debug messages might leak sensitive information
3. **Monitoring**: Clean production logs are essential for monitoring
4. **Scalability**: Debug output affects log aggregation and storage costs
5. **Compliance**: Production systems often require clean, controlled logging

### Legacy Code Migration Pattern

For existing `std::cout` debug statements:

```cpp
// BEFORE (Legacy code - DO NOT USE)
std::cout << "[DEBUG] User " << userId << " logged in" << std::endl;

// AFTER (Modern approach - ALWAYS USE)
LOG_DEBUG("User " + std::to_string(userId) + " logged in successfully");
```

### Testing Debug Configuration

Always test your debug output with different log levels:

```bash
# Test debug level (should show debug messages)
LOG_LEVEL=debug ./server

# Test info level (should hide debug messages)
LOG_LEVEL=info ./server

# Test production level (should hide debug messages)
LOG_LEVEL=warning ./server
```

## ⚠️ CRITICAL: uWebSockets Rules

### MANDATORY: onData + onAborted Pattern
**NEVER use `res->onData()` without `res->onAborted()`:**

```cpp
// ❌ WRONG - This will crash the server when client disconnects!
res->onData([this, res, buffer = std::move(buffer)](std::string_view data, bool last) mutable {
    buffer.append(data.data(), data.length());
    if (last) {
        // Process request...
    }
});
// Missing onAborted() - SERVER CRASH!
```

**ALWAYS pair onData with onAborted:**

```cpp
// ✅ CORRECT - Safe from client disconnections
res->onData([this, res, buffer = std::move(buffer)](std::string_view data, bool last) mutable {
    buffer.append(data.data(), data.length());
    if (last) {
        // Process request...
    }
});

res->onAborted([]() {
    LOG_WARNING("Request aborted by client");
});
```

### uWebSockets Integration Checklist
When implementing POST/PUT endpoints with request body:
1. **ALWAYS** add `res->onAborted()` after `res->onData()`
2. Use `std::move(buffer)` in lambda capture for performance
3. Check `if (last)` before processing complete request
4. Add appropriate logging in `onAborted` for debugging
5. Never access `res` or controller members after client disconnect

### Common uWebSockets Crashes
- **"Empty reply from server"** → Missing `onAborted()` callback
- **Segmentation fault in POST** → Client disconnect without `onAborted()` handling
- **Undefined behavior in lambdas** → Accessing invalid `this` pointer after disconnect

### uWebSockets Best Practices
```cpp
// Template for safe POST endpoint
void Controller::safePostEndpoint(uWS::HttpResponse<false>* res, uWS::HttpRequest* req) {
    std::string buffer;
    res->onData([this, res, buffer = std::move(buffer)](std::string_view data, bool last) mutable {
        buffer.append(data.data(), data.length());
        
        if (last) {
            try {
                // Process request safely
                auto jsonBody = nlohmann::json::parse(buffer);
                // ... business logic ...
                this->json(res, response);
            } catch (const std::exception& e) {
                LOG_ERROR("Error in endpoint: " + std::string(e.what()));
                serverError(res, "Processing error");
            }
        }
    });

    // CRITICAL: Always add this
    res->onAborted([]() {
        LOG_WARNING("Client disconnected during request processing");
    });
}
```

## ⚠️ CRITICAL: Controller Initialization Rules

### MANDATORY: Lazy Initialization Pattern
**NEVER initialize services in controller constructors (static initialization order fiasco):**

```cpp
// ❌ WRONG - This causes static initialization order fiasco!
class DomainController : public routing::Controller {
public:
    DomainController() {
        // BAD: Initializing during static initialization before main()
        domainStorage_ = std::make_unique<DomainStorage>();  // Can crash!
        jobQueue_ = std::make_unique<JobQueue>();           // Can crash!
    }
private:
    std::unique_ptr<DomainStorage> domainStorage_;
    std::unique_ptr<JobQueue> jobQueue_;
};
```

**ALWAYS use lazy initialization with getter methods:**

```cpp
// ✅ CORRECT - Safe lazy initialization pattern
class DomainController : public routing::Controller {
public:
    DomainController() {
        // Empty constructor - no initialization during static startup
    }
    
private:
    mutable std::unique_ptr<DomainStorage> domainStorage_;
    mutable std::unique_ptr<JobQueue> jobQueue_;
    
    // Lazy initialization helpers
    DomainStorage* getDomainStorage() const {
        if (!domainStorage_) {
            try {
                LOG_INFO("Lazy initializing DomainStorage");
                domainStorage_ = std::make_unique<DomainStorage>();
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to lazy initialize DomainStorage: " + std::string(e.what()));
                throw;
            }
        }
        return domainStorage_.get();
    }
    
    JobQueue* getJobQueue() const {
        if (!jobQueue_) {
            try {
                LOG_INFO("Lazy initializing JobQueue");
                jobQueue_ = std::make_unique<JobQueue>();
            } catch (const std::exception& e) {
                LOG_ERROR("Failed to lazy initialize JobQueue: " + std::string(e.what()));
                throw;
            }
        }
        return jobQueue_.get();
    }
};
```

### Why Lazy Initialization is Critical
1. **Prevents Static Initialization Order Fiasco:** Services initialize after Docker containers are ready
2. **Better Error Handling:** Can catch and handle initialization failures gracefully
3. **Resource Efficiency:** Only creates objects when actually needed
4. **Timing Independence:** No race conditions with service startup
5. **Testability:** Easy to mock and test individual components

### Lazy Initialization Checklist
When creating controllers with service dependencies:
1. **NEVER** initialize services in constructor
2. **ALWAYS** declare service members as `mutable std::unique_ptr<Service>`
3. **ALWAYS** create lazy getter methods with proper error handling
4. **ALWAYS** use getter methods instead of direct member access
5. **ALWAYS** add logging for initialization events

## File Organization

### Header Includes
```cpp
// System headers first
#include <string>
#include <memory>

// Project headers
#include "../../include/Logger.h"
#include "../../include/mongodb.h"

// Third-party headers
#include <mongocxx/client.hpp>
#include <nlohmann/json.hpp>
```

### CMake Integration
When adding new storage classes:
1. Add to `src/storage/CMakeLists.txt`
2. Create static library target
3. Link to main server executable
4. Include in install targets

## API Response Format

### Success Response
```json
{
  "success": true,
  "message": "Operation completed successfully",
  "data": { ... }
}
```

### Error Response
```json
{
  "success": false,
  "message": "Error description",
  "error": "ERROR_CODE"
}
```

## Testing Guidelines

### MongoDB Connection Test
```bash
docker exec mongodb_test mongosh --username admin --password password123 \
--eval "db.adminCommand('ping')"
```

### API Testing
```bash
curl --location 'http://localhost:3000/api/endpoint' \
--header 'Content-Type: application/json' \
--data-raw '{ ... }'
```

### Verify Data Storage
```bash
docker exec mongodb_test mongosh --username admin --password password123 \
--eval "use('search-engine'); db.collection.find().pretty()"
```

## Common Issues and Solutions

### Server Crash: "Empty reply from server" (Most Common)
**Cause:** Missing `res->onAborted()` callback after `res->onData()`
**Solution:** Always pair every `res->onData()` with `res->onAborted()`

### Server Crash: MongoDB Connection
**Cause:** MongoDB instance not initialized
**Solution:** Use `MongoDBInstance::getInstance()` before creating clients

### Server Crash: Static Initialization Order Fiasco
**Cause:** Controller constructor initializes services during static startup (before Docker containers ready)
**Solution:** Use lazy initialization pattern with getter methods instead of constructor initialization

### POST Endpoints Crash on Client Disconnect
**Cause:** Client disconnects during `onData` processing without `onAborted` handler
**Solution:** Add `res->onAborted([](){ LOG_WARNING("Request aborted"); });`

### Undefined Reference Errors
**Cause:** Missing library in CMakeLists.txt
**Solution:** Add library to target_link_libraries in CMakeLists.txt

### Collection Not Found
**Cause:** Inconsistent collection names
**Solution:** Use same collection name in code and imports

## Docker Environment

### Container Names
- `core` - Main application server
- `mongodb_test` - MongoDB database
- `redis` - Redis cache
- `browserless` - Headless Chrome for SPA rendering

### Environment Variables
- `LOG_LEVEL` - **CRITICAL**: Logging verbosity level (debug, info, warning, error, none)
- `MONGODB_URI` - MongoDB connection string (default: mongodb://admin:password123@mongodb:27017)
- `REDIS_URL` - Redis connection string
- `BROWSERLESS_URL` - Browserless service URL

## Frontend Integration

### Static Files
- Location: `/public/` directory
- Served by: StaticFileController
- Caching: 1-year browser cache for JS/CSS

### Templates
- Location: `/templates/` directory
- Engine: Inja templating
- Localization: `/locales/` directory

### CSS Best Practices

#### ⚠️ CSS Class Reuse and DRY Principle
**ALWAYS prefer reusing existing CSS classes over creating new ones:**

```css
/* ❌ WRONG - Duplicating styles */
.new-component {
    padding: var(--space-4) 0;
    font-family: "Vazirmatn FD", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}

.another-component {
    padding: var(--space-4) 0;
    font-family: "Vazirmatn FD", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
```

**✅ CORRECT - Using CSS custom properties and reusing classes:**
```css
:root {
    --font-family: "Vazirmatn FD", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}

.content-section {
    padding: var(--space-4) 0;
    font-family: var(--font-family);
}

/* Reuse the existing class */
.new-component {
    /* Extend existing class or use utility classes */
}
```

#### CSS Custom Properties (Variables)
- **ALWAYS** define reusable values as CSS custom properties in `:root`
- Use semantic names: `--font-family`, `--primary-color`, `--border-radius`
- Reference existing variables before creating new ones
- Group related variables together

#### Class Naming and Organization
- Use BEM methodology for component-specific classes
- Create utility classes for common patterns (spacing, typography, colors)
- Prefer composition over inheritance
- Document complex CSS patterns with comments

#### CSS Checklist
Before adding new CSS:
- [ ] Check if existing classes can be reused
- [ ] Verify if CSS custom properties already exist for the values
- [ ] Consider creating utility classes for repeated patterns
- [ ] Use semantic class names
- [ ] Follow the existing CSS architecture

### JavaScript Best Practices

#### ⚠️ NO Inline JavaScript - Content Security Policy Compliance
**NEVER use inline event handlers (onclick, onload, etc.) due to CSP restrictions:**

```javascript
// ❌ WRONG - Inline JavaScript (violates CSP)
<button onclick="copyToClipboard('text')">Copy</button>
<span onclick="handleClick()">Click me</span>

// ✅ CORRECT - Use data attributes and event listeners
<button data-copy-text="text" class="copy-btn">Copy</button>
<span data-action="click" class="clickable">Click me</span>

// Add event listeners in JavaScript
document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const text = this.getAttribute('data-copy-text');
        copyToClipboard(text);
    });
});
```

#### JavaScript Security Rules
- **ALWAYS** use `data-*` attributes instead of inline event handlers
- **ALWAYS** attach event listeners using `addEventListener()`
- **NEVER** use `onclick`, `onload`, `onsubmit`, etc. in HTML
- **ALWAYS** use event delegation for dynamically created elements
- **ALWAYS** follow CSP (Content Security Policy) guidelines

#### JavaScript Event Handling Pattern
```javascript
// ✅ CORRECT Pattern for reusable components
function createCopyButton(text, label) {
    const button = document.createElement('button');
    button.className = 'copy-btn';
    button.setAttribute('data-copy-text', text);
    button.setAttribute('title', label);
    button.innerHTML = '<svg>...</svg>';
    
    // Add event listener
    button.addEventListener('click', function() {
        const textToCopy = this.getAttribute('data-copy-text');
        copyToClipboard(textToCopy);
    });
    
    return button;
}
```

#### JavaScript Checklist
Before adding new JavaScript:
- [ ] No inline event handlers (onclick, onload, etc.)
- [ ] Use data attributes for dynamic content
- [ ] Add event listeners in JavaScript code
- [ ] Follow CSP guidelines
- [ ] Use event delegation for dynamic elements
- [ ] Implement proper error handling

## Security Best Practices

1. Always validate input data
2. Use prepared statements for database queries
3. Implement rate limiting for APIs
4. Use HTTPS in production
5. Sanitize user-provided URLs
6. Validate email formats
7. Check mobile number formats

## Performance Optimization

1. Use connection pooling for MongoDB
2. Implement Redis caching for frequently accessed data
3. Use async operations where possible
4. Minimize database round trips
5. Use indexes on frequently queried fields

## Documentation Requirements

When adding new features:
1. Update `README.md` with feature description
2. Add API documentation to `docs/api/`
3. Update project structure if new files added
4. Document any new environment variables
5. Add examples to documentation

## Git Commit Messages

Format: `type: description`

Types:
- `feat:` New feature
- `fix:` Bug fix
- `docs:` Documentation changes
- `refactor:` Code refactoring
- `test:` Test additions/changes
- `perf:` Performance improvements
- `chore:` Maintenance tasks

## Code Review Checklist

Before submitting code:
- [ ] **uWebSockets: Every `onData` paired with `onAborted`**
- [ ] **Controllers: Use lazy initialization pattern (no service init in constructor)**
- [ ] **Debug Output: Use `LOG_DEBUG()` instead of `std::cout` (configurable via LOG_LEVEL)**
- [ ] MongoDB instance properly initialized
- [ ] Error handling implemented
- [ ] Logging added for debugging
- [ ] Documentation updated
- [ ] Tests written/updated
- [ ] CMakeLists.txt updated if needed
- [ ] No memory leaks
- [ ] Thread-safe where required

## Important File Paths

- Controllers: `src/controllers/`
- Storage: `src/storage/`
- Headers: `include/`
- MongoDB singleton: `include/mongodb.h`
- API docs: `docs/api/`
- Templates: `templates/`
- Static files: `public/`

## Memory Management

1. Use smart pointers (`std::unique_ptr`, `std::shared_ptr`)
2. Avoid raw pointers unless necessary
3. RAII pattern for resource management
4. Clean up in destructors

## Thread Safety

1. Use mutexes for shared resources
2. Prefer lock_guard over manual lock/unlock
3. Minimize lock scope
4. Avoid deadlocks with consistent lock ordering

## Debugging Tips

1. Check Docker logs: `docker logs core --tail 50`
2. MongoDB logs: `docker logs mongodb_test`
3. Use `LOG_DEBUG()` liberally during development
4. Test with curl before UI integration
5. Verify MongoDB connection independently

## Production Deployment

1. Set appropriate environment variables
2. Enable HTTPS
3. Configure proper MongoDB authentication
4. Set up monitoring and alerting
5. Implement backup strategies
6. Use production Docker images from GHCR

Remember:
1. Always test MongoDB connections with the singleton pattern to avoid server crashes!
2. **CRITICAL: Every `res->onData()` MUST be paired with `res->onAborted()` to prevent crashes!**
3. **CRITICAL: Use lazy initialization in controllers - NEVER initialize services in constructors!**
4. **CRITICAL: Use `LOG_DEBUG()` instead of `std::cout` - configure via `LOG_LEVEL` environment variable!**
